# Finance 2019 (minor changes)

# Як працює API IEX

[IEXAPIS with symbol FB](https://cloud.iexapis.com/stable/stock/FB/quote?token=pk_2a0bb90fae2c4d6b947584c1d42d8e1f)

---

### Специфікація

**`register`**

Завершіть реалізацію `register` таким чином, щоб він дозволяв користувачеві створювати обліковий запис за допомогою форми.

- Вимагайте, щоб користувач ввів ім'я користувача (username), реалізувавши це як текстове поле із ім'ям `username`. Виводьте вибачення, якщо ввід користувача є пустим чи таке ім'я користувача вже існує.

- Вимагайте, щоб користувач ввів пароль, реалізувавши його як текстове поле із ім'ям `password`, а потім ввів цей же пароль ще раз, реалізувавши як текстове поле із ім'ям `confirmation`. Виводьте вибачення, якщо ввід користувача є пустим чи паролі не збігаються.

- Відправляйте ввід користувача за допомогою `POST` запиту на адресу `/register`.

- Додайте нового користувача у таблицю `users` (за допомогою `INSERT`), зберігаючи при цьому хеш паролю користувача, а не сам пароль. Хешуйте пароль користувача за допомогою функції `generate_password_hash`.

- Скоріше за все, ви захочете створити новий шаблон (наприклад, `register.html`), який буде достатньо схожим на `login.html`.

Щойно ви реалізували `register` коректно, ви матимете змогу зареєструвати обліковий запис і увійти до системи (оскільки `login` і `logout` вже працюють)! Ви також зможете побачити відповідні рядки у таблиці через `phpLiteAdmin` чи `sqlite3`.

**`quote`**

Завершіть реалізацію `quote` таким чином, щоб він дозволяв користувачеві дізнаватись поточну ціну акції.

Вимагайте, щоб користувач ввів символ акції (symbol), реалізувавши його як текстове поле із ім'ям `symbol`.

Відправляйте ввід користувача за допомогою `POST` запиту на адресу `/quote`.

Скоріше за все, ви захочете створити два нові шаблони (наприклад, `quote.html` і `quoted.html`). Коли користувач відвідує `/quote` через `GET` запит, відображайте один з цих шаблонів, в середині якого має бути HTML форма, що посилає POST до `/quote`. У відповідь на `POST`, `quote` повинна показувати другий шаблон, в який буде вбудовано одне чи більше значень цін, що були отримані з `lookup`.

**`buy`**

Завершіть реалізацію `buy` таким чином, щоб він дозволяв користувачеві купувати акції.

- Вимагайте, щоб користувач ввів символ акції (symbol), реалізувавши його як текстове поле із ім'ям `symbol`. Виводьте вибачення, якщо ввід користувача є пустим чи такого символу не існує (відповідно до значення, що повернув пошук `lookup`).

- Вимагайте, щоб користувач ввів кількість акцій, реалізувавши текстове поле із ім'ям shares. Виводьте вибачення, якщо ввід користувача не є додатнім цілим числом.

- Відправляйте ввід користувача за допомогою `POST` запиту на адресу `/buy`.

- Скоріше за все, ви захочете викликати `lookup`, щоб дізнатись поточну ціну акції.

- Скоріше за все, ви захочете використати `SELECT`, щоб дізнатись, скільки грошей є у користувача в таблиці `users`.

- Додайте одну чи більше таблиць до `finance.db`, що дозволять стежити за покупками користувачів. Зберігайте достатньо інформації, щоб знати, хто купив які акції, за якою ціною і коли.

  - Використовуйте потрібні типи `SQLite`.

  - Визначте `UNIQUE` індекси на всіх полях, що мають бути унікальними.

  - Визначте неунікальні індекси на всіх полях, за допомогою яких ви будете виконувати пошук (через `SELECT` із `WHERE`).

- Виводьте вибачення, не проводячи покупку, якщо користувачу не вистачає грошей, щоб придбати задану кількість акцій при поточній ціні.

- Вам не варто хвилюватись про стан перегонів чи використання транзакцій.

Щойно ви реалізуєте `buy` коректно, ви зможете дивитись покупки користувача у вашій новій (нових) таблиці (таблицях) через `phpLiteAdmin` чи `sqlite3`.

**`index`**

Завершіть реалізацію `index` таким чином, щоб він відображав HTML-таблицю, що показує для користувача, що зараз увійшов до системи, якими акціями цей користувач володіє, скількома акціями він володіє, поточну ціну кожної акції та сумарну вартість кожного вкладу (тобто кількість акцій помножена на їх ціну). Також відобразіть поточний грошовий баланс користувача та його загальний статок (тобто сумарну вартість акцій, додану до грошового балансу).

- Скоріше за все, вам захочеться виконати кілька `SELECT`-ів. Залежно від того, як ви реалізували вашу таблицю (таблиці), вам можуть знадобитись `GROUP BY`, `HAVING`, `SUM` і/або `WHERE`.

- Скоріше за все, ви захочете викликати `lookup` для кожної акції.

**`sell`**

Завершіть реалізацію `sell` таким чином, щоб він дозволяв користувачеві продавати акції (якими він чи вона володіє).

- Вимагайте, щоб користувач ввів символ акції, реалізувавши `select` меню вибору із ім'ям `symbol`. Відображайте вибачення, якщо користувач не обрав символ акції або якщо (якимось чином на час відправки) користувач не володіє такими акціями.

- Вимагайте, щоб користувач ввів кількість акцій, реалізувавши текстове поле із ім'ям `shares`. Відображайте вибачення, якщо ввід користувача не є додатнім цілим числом чи якщо користувач не володіє таким числом цих акцій.

- Відправляйте ввід користувача за допомогою `POST` запиту на адресу `/sell`.

- Вам не варто хвилюватись про стан перегонів чи використання транзакцій.

**`history`**

Завершіть реалізацію `history` таким чином, щоб він відображав HTML-таблицю, що показує для користувача всі його транзакції, показуючи рядок за рядком всі його покупки та продажі.

- Для кожного рядка вкажіть, акція була продана чи куплена, а також вкажіть її символ, ціну покупки чи продажу, кількість куплених чи проданих акцій, а також дату і час, коли транзакцію було проведено.

- Вам, можливо, необхідно буде змінити таблицю, яку ви створювали для покупок, чи доповнити її додатковою таблицею. Намагайтесь мінімізувати надлишковість.

**`check`**

Завершіть реалізацію `check` таким чином, щоб він перевіряв, чи доступне ім’я користувача.

- Через `GET` маршрут має приймати параметр HTTP під назвою `username`.

- Якщо значення `username` є довжиною щонайменше 1 і не належить вже користувачеві у базі даних, тоді маршрут має повертати у форматі **JSON** `true`, повідомляючи, що ім’я користувача вільне (зараз). У іншому випадку він має повертати у форматі **JSON** `false`. Пригадайте, що `jsonify` у **Flask** може повертати значення у форматі **JSON**.

Нарешті, покращіть ваш шаблон для register за допомогою JavaScript таким чином, щоб попереджати надсилання вашої форми, якщо введене ім’я користувача вже зайняте, повідомивши про це користувача за допомогою alert або Bootstrap alert чи validation.

Використайте Ajax (наприклад, метод $.get з jQuery) щоб запитати у /check перевірку доступності введеного імені користувача.

Пам’ятайте, що ви можете попередити надсилання форми за допомогою preventDefault, та можете програмно надіслати форму (визнану вами валідною) за допомогою submit.

Власні доповнення:

- змінив в helper.py, взяв чужий токен з сайту [побачити цей сайт](https://www.weblancer.net/projects/veb-programmirovanie-31/javascript-api-1027123/) (вибачте, це в цілях тесту)

```py
def lookup(symbol):
    """Look up quote for symbol."""

    # Contact API
    try:
        # Sorry! This key for test.
        # site - https://www.weblancer.net/projects/veb-programmirovanie-31/javascript-api-1027123/
        response = requests.get(f"https://cloud.iexapis.com/stable/stock/{urllib.parse.quote_plus(symbol)}/quote?token=pk_2a0bb90fae2c4d6b947584c1d42d8e1f")
        response.raise_for_status()
    except requests.RequestException:
        return None

    # Parse response
    try:
        quote = response.json()
        return {
            "name": quote["companyName"],
            "price": float(quote["latestPrice"]),
            "symbol": quote["symbol"]
        }
    except (KeyError, TypeError, ValueError):
        return None
```
