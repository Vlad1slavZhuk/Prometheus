# caesar.c

### Et tu?
Кажуть, що Цезар (так, той самий Цезар) зашифровував усі конфіденційні повідомлення (тобто змінював їх таким чином, щоб можна було відновити оригінал) шляхом зсуву кожної букви на кілька кроків. Наприклад, він міг написати A як B, B як C, C як D ... Z як A. А отже, щоб сказати комусь HELLO, Цезар міг написати IFMMP. Після отримання такого повідомлення від Цезаря, отримувачі повинні були «*розшифрувати*» повідомлення шляхом зсуву літер у зворотньому напрямку на таку саму кількість кроків.

Секретність такої «*криптосистеми*» полягала у тому, що тільки Цезар і отримувач повідомлення знали цей секрет – кількість кроків, на яку Цезар зсунув літери (наприклад, 1). За нинішніми стандартами, все це не так вже й безпечно, але якщо ви – перша людина у світі, яка займається подібними речами, ще й як безпечно!

Незашифрований текст зазвичай називають **звичайний текст**. Зашифрований текст зазвичай так і називають **зашифрований текст**. Секретна інформація, що використовується при шифруванні, називається ключем.

На рисунку нижче зображено, як слово `HELLO` із використанням ключа 1 шифрується у `IFMMP`:

Звичайний текст | **H** | **E** | **L** | **L** | **O** |
--------------- | ------| ----- | ----- | ----- | ----- |
+ ключ | 1 | 1 | 1 | 1 | 1 |
= шифрований текст | I | F | M | M | P |

Якщо говорити загально, алгоритм Цезаря (тобто шифр Цезаря) шифрує повідомлення шляхом «обертання» кожної букви на *k* позицій. Формальніше, якщо *p* – якийсь звичайний текст (незашифрованне повідомлення), *p*<sub>i</sub> – це i<sup>ий</sup> символ у *p*, а *k* – секретний ключ (тобто невід'ємне ціле число), тоді кожна буква *c*<sub>i</sub> у зашифрованному тексті *c*, обраховується так:

*c*<sub>i</sub> = (*p*<sub>i</sub> + *k*) % 26

де `% 26` означає «залишок від ділення на 26». Ця формула, мабуть, робить так, що шифр видається складнішим, ніж насправді, але це лише лаконічна форма точного вираження суті алгоритму. Насправді, задля прикладу, подумайте про А (або а) як про В (або b) як про 1, і так далі, H (або h) як про 7, I (або i) як про 8 і так далі, а Z (або z) як про 25. Уявімо, що Цезар хотів сказати «Hi» комусь конфіденційно, використвавши цього разу ключ *k* = 3. Тож його звичайний текст *p* – це «Hi», у цьому випадку перша літера його звичайного тексту *p*<sub>0</sub> – це H (вона ж 7), а друга літера *p*<sub>1</sub> – це i (вона ж 8). Перша літера зашифрованого тексту *c*<sub>0</sub>, таким чином K, а друга - *c*<sub>1</sub>, відповідно L.

Давайте напишемо програму під назвою `caesar`, яка дозволить вам зашифрувати повідомлення шифром Цезаря. Під час запуску програми користувачем, він має обрати за допомогою аргументів командного рядка, яким буде ключ у секретному повідомленні, яке він введе під час роботи програми. Не треба очікувати, що ключем обов’язково буде число, але можна вважати, що якщо це число, то це буде додатне ціле число.

Ось кілька прикладів очікуваної роботи цієї програми. Наприклад, якщо користувач вводить ключ `1` та текст `HELLO`:

```c
$ ./caesar 1
plaintext:  HELLO
ciphertext: IFMMP
```

Ось так може працювати програма, якщо користувач введе ключ `13` та текст `hello, world`:

```c
$ ./caesar 13
plaintext:  hello, world
ciphertext: uryyb, jbeyq
```

Зверніть увагу, що ані кома, ані пробіл не були «змінені» шифром. Він змінює виключно літерні символи!

Розглянемо ще? Ось так працюватиме програма, якщо користувач введе ключ `13` ще раз, але для складнішого тексту:

```js
$ ./caesar 13
plaintext:  be sure to drink your Ovaltine
ciphertext: or fher gb qevax lbhe Binygvar
```
---

Зверніть увагу, що регістр символів оригінального повідомлення збережено. Літери у нижньому регістрі залишились маленькими, а літери у верхньому регістрі лишились великими.

А якщо користувач не хоче співпрацювати?

```c
$ ./caesar HELLO
Usage: ./caesar key
```

Або зовсім не хоче співпрацювати?

```c
$ ./caesar
Usage: ./caesar key
```

Або навіть…

```c
$ ./caesar 1 2 3
Usage: ./caesar key
```
---

# vigenere.c

### Ooh, la la!

Шифр Віженера є покращенням відносно шифру Цезаря. Шифрування у ньому відбувається шляхом використання *послідовності* ключів (або *ключового слова*).

Тобто, якщо *p* – це звичайний текст і *k* – ключове слово (як, наприклад, алфавітний рядок: де А (або а) представляє 0, B (або b) представляє 1, C (або c) представляє 2, Z представляє с 25), то кожна літера *c*<sub>i</sub>, в зашифрованому тексті *c* обраховується як:

*c*<sub>i</sub> = (*p*<sub>i</sub> + *k*<sub>j</sub>) % 26

Зауважте, що шифр використовує *k*<sub>j</sub> проти *k*. І пам'ятайте, що, якщо довжина *k* менша за довжину *p*, то літери в *k* мають бути циклічно використані стільки раз, скільки потрібно для шифрування *p*.

Інакше кажучи, якби сам Віженер хотів конфіденційно сказати комусь HELLO із використанням ключового слова, скажемо, ABC, він би зашифрував H за допомогою ключа 0 (тобто A), Е – за допомогою ключа 1 (тобто B), а першу букву L – за допомогою ключа 2 (тобто С). На цьому етапі в нього б закінчились букви у ключовому слові, і тому він знову використав би частину ключового слова, щоб зашифрувати другу L ключем 0 (тобто A), а букву O – ключем 1 (тобто B). Отже, він написав би HELLO як HFNLP, як на рисунку нижче:

Звичайний текст | **H** | **E** | **L** | **L** | **O** |
--------------- | ------| ----- | ----- | ----- | ----- |
+ ключ | A | B | C | A | B |
(змінне значення) | 0 | 1 | 2 | 0 | 1 |
= зашифрований текст | H | F | N | L | P |

Давайте напишемо програму `vigenere`, яка дозволяє шифрувати повідомлення за допомогою коду Віженера. Під час запуску програми користувачем, він має обрати за допомогою аргументу командного рядка, яким буде ключ у секретному повідомленні, яке він введе під час роботи програми.

Ось кілька прикладів того, як може працювати програма:

```c
$ ./vigenere bacon
plaintext:  Meet me at the park at eleven am
ciphertext: Negh zf av huf pcfx bt gzrwep oz
```

або коли користувач вводить ключове слово, але воно не повністю складається з літер:

```c
$ ./vigenere 13
Usage: ./vigenere keyword
```

Або коли користувач не вводить ключове слово:

```c
$ ./vigenere
Usage: ./vigenere keyword
```

Або коли користувач вводить забагато ключових слів:

```
$ ./vigenere bacon and eggs
Usage: ./vigenere keyword
```
---