# Speller (з використанням хеш-таблиці)

Створіть програму, яка перевірятиме орфографію у файлі, на кшталт розміщеної нижче, із використанням хеш-таблиці.

```c
$ ./speller texts/lalaland.txt
MISSPELLED WORDS

[...]
AHHHHHHHHHHHHHHHHHHHHHHHHHHHT
[...]
Shangri
[...]
fianc
[...]
Sebastian's
[...]

WORDS MISSPELLED:
WORDS IN DICTIONARY:
WORDS IN TEXT:
TIME IN load:
TIME IN check:
TIME IN size:
TIME IN unload:
TIME IN TOTAL:
```

### Специфікація

Що ж тепер ви маєте реалізувати `load`, `size`, `check`, і `unload` так ефективно, як це тільки можливо, щоб мінімізувати `TIME IN load`, `TIME IN check`, `TIME IN size`, та `TIME IN unload`. Можливо, трохи не зрозуміло, що в даному контексті означає "мінімізувати", оскільки числа будуть змінюватись залежно від того, з яким словником і для якого тексту ви запустите `speller`. Однак, це і є найскладніша і найвеселіша частини цієї задачі. Це ваш шанс придумати власний дизайн програми. Звичайно, ми запрошуємо вас мінімізувати використання пам’яті, але зараз вашим основним ворогом є час. Перед тим, як ви почнете - ось деякі специфікації від нас.

- Ви не можете змінювати `speller.c` або `Makefile`.

- Ви можете змінювати `dictionary.c` (і повинні це зробити, щоб завершити реалізацію `load`, `size`, `check`, та `unload`), але ви не можете змінювати оголошення (тобто, прототипи) `load`, `size`, `check`, чи `unload`. Ви можете, втім, додавати нові функції та (локальні або глобальні) змінні до `dictionary.c`.

- Ви можете змінювати `dictionary.h`, але не можете змінювати оголошення `load`, `size`, `check`, чи `unload`.

- Ваша реалізація `check` повинна бути нечутлива до регістру. Іншими словами, якщо `foo` є в словнику, то checkповинен повернути `true` для будь-якого слова, що відрізняється від `foo` лише регістром символів. Будь-яке слово з списку `foo`, `foO`, `fOo`, `fOO`, `fOO`, `Foo`, `FoO`, `FOo`, та `FOO` є коректним.

- Ваша реалізація `check` повинна повертати `true` лише для слів, які дійсно є в `dictionary`. Будьте обачні та не повертайте `true` незалежно від словника для слів, які часто зустрічаються (наприклад `the`), щоб уникнути проблем, якщо ми передамо вашій реалізації словник `dictionary` без них. Вам не потрібно повертати `true` для присвійних прикметників, якщо вони відсутні у словнику `dictionary`. Наприклад, якщо у словнику є слово `foo`, але немає `foo’s`, `check` має повернути `true` для `foo` і `false` для `foo’s`. **Головне правило: повертати `true` лише для слів, що знаходяться у словнику без урахування регістру**

- Ви можете вважати що будь-який словник `dictionary`, переданий вашій програмі, буде структурований так само, як наш: лексикографічно відсортований зверху вниз, одне слово у рядку, кожне з яких закінчується на `\n`. Також можете вважати, що словник містить хоча б одне слово та жодне слово не буде довше за `LENGTH` (константа у `dictionary.h`) символів. Крім того, жодне слово не з’явиться частіше одного разу і кожне слово складається лише з символів (букв алфавіту) у нижньому регістрі та апострофів. Також, жодне слово не почнеться з апострофа

- Ви можете вважати що `check` буде отримувати лише рядки з символами з алфавіту та, можливо, апострофами.

- Ваша програма перевірки правопису має обов’язково приймати `text` та, опціонально, `dictionary` як вхідні дані. Попри те, що вам, можливо, захочеться попередньо обробити словник за замовчуванням, щоб визначити найкращу для нього хеш-функцію, ви не можете зберегти результати такої обробки на диск, щоб надалі завантажувати з диска до пам'яті для пришвидшення наступних викликів.

- Ви можете змінювати значення `N` та реалізацію `hash`.

- У вашій програмі не має бути витоків пам'яті. Обов’яково перевірте на витоки за допомогою `valgrind`.